# Zookeeper 分布式服务框架

拜占庭将军问题[The Byzantine Generals Problem]

http://www.8btc.com/baizhantingjiangjun

Part1：拜占庭将军问题是什么

应该明确的是，拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，我们已经假定了信道是没有问题的，并在这个前提下，去做一致性和容错性相关的研究。如果需要考虑信道是有问题的，这涉及到了另一个相关问题：两军问题。

与拜占庭将军相关问题：两军问题

拜占庭将军问题和两军问题实质是不一样的

这两个问题看起来的确有点相似，但是问题的前提和研究方向都截然不同。

白军驻扎在沟渠里，蓝军则分散在沟渠两边。白军比任何一支蓝军都更为强大，但是蓝军若能同时合力进攻则能够打败白军。他们不能够远程的沟通，只能派遣通信兵穿过沟渠去通知对方蓝军协商进攻时间。是否存在一个能使蓝军必胜的通信协议，这就是两军问题。



您可能发现两军问题和拜占庭将军问题有一定的相似性，但我们必须注意的是，通信兵得经过敌人的沟渠，在这过程中他可能被捕，也就是说，两军问题中信道是不可靠的，并且其中没有叛徒之说，这就是两军问题和拜占庭将军问题的根本性不同



两军问题在经典情境下是不可解的，为什么呢？

倘若1号蓝军（简称1）向2号蓝军（简称2）派出了通信兵，若1要知道2是否收到了自己的信息，1必须要求2给自己传输一个回执（因为2发出的回执1并不一定能够收到。所以，1必须再给2发出一个回执说“我收到了”… ...），那么这个系统将永远需要存在一个回执，这对于两方来说都并不一定能够达成十足的确信。更要命的是，我们还没有考虑，通信兵的信息还有可能被篡改。由此可见，经典情形下两军问题是不可解的，并不存在一个能使蓝军一定胜利的通信协议。



我们能不能通过一种相对可靠的方式来解决大部分情形呢?

“两军问题与三次握手”

TCP协议中，A先向B发出一个随机数x，B收到x了以后，发给A另一个随机数y以及x+1作为答复，这样A就知道B已经收到了，因为要破解随机数x可能性并不大；然后A再发回y+1给B，这样B就知道A已经收到了。这样，A和B之间就建立一个可靠的连接，彼此相信对方已经收到并确认了信息。

事实上，A并不会知道B是否收到了y+1；并且，由于信道的不可靠性，x或者y都是可能被截获的，这些问题说明了即使是三次握手，也并不能够彻底解决两军问题，只是在现实成本可控的条件下，我们把TCP协议当作了两军问题的现实可解方法。

是否能够找到一个理论方法来真正的破解两军问题呢？答案是有的，**量子通讯协议**，笔者并没有能力弄清这个颇为高深的问题。据我的理解，处于量子纠缠态的两个粒子，无论相隔多远都能够彼此同步，光是直观的来看，这个效应可以用来实现保密通讯。



但是由于**测不准原理**，一测量粒子状态就会改变其状态，所以通讯时还必须通过不可靠信道发送另一条信息。尽管这个“另一条信息”是不可靠的，但是由于已经存在了一条绝对可靠的信道（量子纠缠），保证了另一条信道即使不可靠也能保证消息是可靠的，否则至少被窃取了一定能够被发现。

因此我们可以相信，至少理论上两军问题是可解的，即存在一种方法，即使利用了不可靠的信道，也能保证信息传递的可靠性。所以，在确保了信道可靠的基础上，我们可以回到拜占庭将军问题上继续讨论。



拜占庭将军问题的场景，并且明确了这个问题的解决是建立在通信兵可以正确的传达信息的基础上的，即信道绝对可信



拜占庭将军问题是一个共识问题: 首先由Leslie Lamport与另外两人在1982年提出，被称为The Byzantine Generals Problem或者Byzantine Failure。核心描述是军中可能有叛徒，却要保证进攻一致，由此引申到计算领域，发展成了一种容错理论。随着比特币的出现和兴起，这个著名问题又重入大众视野。



Byzantine General Problem ——The problem of reaching a consensus among distributed units if some of them give misleading answers. The original problem concerns generals plotting a coup. Some generals lie about whether they will support a particular plan and what other generals told them. What percentage of liars can a decision making algorithm tolerate and still correctly determine a consensus?



拜占庭帝国就是5～15世纪的东罗马帝国，拜占庭即现在土耳其的伊斯坦布尔。我们可以想象，拜占庭军队有许多分支，驻扎在敌人城外，每一分支由各自的将军指挥。将军们只能靠通讯员进行通讯。在观察了敌人以后，忠诚的将军们必须制订一个统一的行动计划。然而，这些将军中有叛徒，他们不希望忠诚的将军们能达成一致，因而影响统一行动计划的制订与传播。问题是：将军们必须有一个算法，使所有忠诚的将军们能够达成一致，而且少数几个叛徒不能使忠诚的将军们做出错误的计划。



#### 解决拜占庭将军问题的算法必须保证

-   所有忠诚的将军基于相同的计划做出决策 (使用相同的方法)

- 少数叛徒不能使忠诚的将军做出错误的计划 (方法要健壮)

    ​

了解过比特币和区块链的人，多少都听说过拜占庭将军问题，或听说过比特币（或区块链）的一个重要成就正是解决了拜占庭将军问题。



Zookeeper是参考Google Chubby实现原理设计实现的一个分布式应用协调系统。Zookeeper的原型系统由Yahoo!开发，目前，由Apache基金会维护，为Hadoop项目的子项目



主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等



Google Chubby [The Chubby lock service for loosely-coupled distributed systems]

Chubby是Google开发的分布式锁系统

Chubby被用于解决以下问题： 
a)	帮助工程师实现服务的高可用性。
b)	为需要主从选择，数据划分的服务提供选择机制和通告方式(advertising the results)。
c)	基于锁的使用接口(lock-based interface)容易理解
d)	分布式一致性算法利用投票的方式来做出决定，并利用镜像冗余获得高可用性



分布式锁服务是现代分布式系统的重要基础之一

Google对分布式锁服务的定义是：分布式锁服务的目标是让客户端的行为得到同步，并使他们关于环境的一些基础信息达到统一

由于是分布式系统的组成部分，分布式锁的首要设计目标包括：可靠性、对于大规模客户端的可用性、以及简单，且易于理解的语义。锁服务的吞吐率和存储能力则是其他需要重点考虑的问题。值得注意的一点是，与这几个重要的目标相比，分布式系统的性能并不是一个需要优先考虑的问题



提到系统，要想到: 可靠性，可用性，易用性，性能，吞吐，存储，计算...







ZooKeeper 是一个为分布式应用所设计的分布的、开源的协调服务。分布式的应用可以建立在同步、配置管理、分组和命名等服务的更高级别的实现的基础之上。 ZooKeeper 意欲设计一个易于编程的环境，它的文件系统使用我们所熟悉的目录树结构。 ZooKeeper 使用 [Java](http://lib.csdn.net/base/javase) 所编写，但是支持 Java 和 C 两种编程语言。

    众所周知，协调服务非常容易出错，但是却很难恢复正常，例如，协调服务很容易处于竞态以至于出现死锁。我们设计 ZooKeeper 的目的是为了减轻分布式应用程序所承担的协调任务。





ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等



一个模型、算法、东西、解决方案

1.  解决什么问题？what?
2.  同类解决方案？
3.  优势？Advantage? 适用场景？
4.  具体怎么解决的、主要步骤？how?
5.  优势依靠哪些办法/步骤得到？





在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此



## 角色

Zookeeper中的角色主要有以下三类

![](assets/Zookeeper_Role.jpg)



系统模型

![](./assets/Zookeeper_sysmodel.jpg)





## 设计目的

-   最终一致性: client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。
-   可靠性: 具有简单、健壮、良好的性能，如果消息m被一台服务器接受，那么它将被所有的服务器接受。
-   实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。（TODO:不保证强一致性的意思？）
-   等待无关(wait-free): 慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。
-   原子性: 更新只能成功或者失败，没有中间状态。
-   顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。










## ZooKeeper 典型的应用场景

Zookeeper 从设计模式角度来看，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式



### 统一命名服务（Name Service）





#### ZooKeeper数据模型和层次命名空间

提供的命名空间与标准的文件系统非常相似。一个名称是由通过斜线分隔开的路径名序列所组成的。ZooKeeper中的每一个节点是都通过路径来识别。 
下图是Zookeeper中节点的数据模型，这种树形结构的命名空间操作方便且易于理解。

![](./assets/Zookeeper_namespace.gif)





#### ZooKeeper中节点和临时节点

ZooKeeper的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。从这样一类既含有数据，又作为路径表标示的节点的特点中，可以看出，ZooKeeper的节点既可以被看做是一个文件，又可以被看做是一个目录，它同时具有二者的特点。为了便于表达，今后我们将使用Znode来表示所讨论的ZooKeeper节点。



Znode维护着数据、ACL（access control list，访问控制列表）、时间戳等交换版本号等数据结构，它通过对这些数据的管理来让缓存生效并且令协调更新。每当Znode中的数据更新后它所维护的版本号将增加，这非常类似于数据库中计数器时间戳的操作方式。



Znode还具有原子性操作的特点：命名空间中，每一个Znode的数据将被原子地读写。读操作将读取与Znode相关的所有数据，写操作将替换掉所有的数据。除此之外，每一个节点都有一个访问控制列表，这个访问控制列表规定了用户操作的权限。



ZooKeeper中同样存在临时节点。这些节点与session同时存在，当session生命周期结束，这些临时节点也将被删除。临时节点在某些场合也发挥着非常重要的作用。























