# 僵尸进程



# 定义

In UNIX System terminology, a process that has terminated,but whose parent has not yet waited for it, is called a zombie.

在UNIX 系统中,一个进程结束了,但是他的父进程没有等待(调用wait / waitpid)他, 那么他将变成一个僵尸进程.  在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用 waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵尸进程。



wait / waitpid / fork() / SIGCHLD



如何查看linux系统上的僵尸进程，如何统计有多少僵尸进程？

```sh
ps -ef | grep defunct

# ps 查找状态为Z的进程，Z就是代表zombie process,僵尸进程的意思

# top命令查看时有一栏为S,如果状态为Z说明它就是僵尸进程。
Tasks:  95 total,   1 running,  94 sleeping,   0 stopped,   0 zombie
```



# wait & waitpid

系统中的僵尸进程都要由wait系统调用来回收

## 函数原型

```c++
#include<sys/types.h>
#include<sys/wait.h>
// 
// 执行成功则返回子进程识别码(PID) ,如果有错误发生则返回返回值-1。失败原因存于 errno 中
pid_t wait(int *status);
```

进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。



```c++
// 例子
int main()
{
    pid_t pc, pr;
    pc = fork();
    if (pc < 0) {
        // 出错
    }  else if ( pc == 0) {
        // 子进程
    } else {
        // 父进程本身
        pr = wait(NULL);
        if ( pr > 0 ) {
           // 子进程正常返回 
        } else {
           // 出错了
        }
          
    }
    
}
```





# SIGCHLD



# 杀死僵尸进程

一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。





# 如何避免僵尸进程

处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下 可以简单地将 SIGCHLD信号的操作设为SIG_IGN。

```c++
signal(SIGCHLD,SIG_IGN);
```





两次fork()，而且使紧跟的子进程直接退出，是的孙子进程成为孤儿进程，从而init进程将负责清除这个孤儿进程



# ref

 http://www.cnblogs.com/yuxc/archive/2012/11/04/2753391.html

