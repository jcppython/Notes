# 僵尸进程



### 1. 定义

In UNIX System terminology, a process that has terminated, but whose parent has not yet waited for it, is called a zombie.



### 2. 如何产生

如定义所描述: 当进程结束了，但其父进程没有等待他(wait / waitpid)，将成为幽魂--僵尸进程



### 3. 为何存在

目的是维护子进程信息，以便父进程在以后某个时间获取，这些信息包括: 子进程的ID，终止状态，资源利用信息



虽然如此，我们并不喜欢僵尸进程，它占据内核空间，它是如何产生的？如何去有效避免它？



### 4. 如何避免

fork子进程之后， 一定要wait它们



##### 4.1 谁产生，谁负责

```c++
// 例子
int main()
{
    pid_t pc, pr;
    pc = fork();
    if (pc < 0) {
        // 出错
    }  else if ( pc == 0) {
        // 子进程
    } else {
        // 父进程本身
      
        // 如果没有此处的wait，上面的子进程将成为zombie
        pr = wait(NULL);
        if ( pr > 0 ) {
           // 子进程正常返回 
        } else {
           // 出错了
        }
          
    }
    
}
```



##### 4.2 利用内核通知

要指定，子进程退出的时候，内核会给父进程一个SIGCHLD信号，可以通过捕获它处理，从而达到清理防止僵尸进程的目的



```c
void sig_chld( int signo ) {
    pid_t pid;
    int stat;
    pid = wait(&stat);    
    printf( "child %d exit\n", pid );
    return;
}

int main() {
    // 注册一个信号处理函
    signal(SIGCHLD,  &sig_chld);
}
```



捕获SIGCHLD信号并且调用wait来清理退出的进程，仍然不能彻底避免产生僵尸进程



这样一种场景：如果父进程fork出N个子进程，几乎同时所有子进程结束，在sig_child处理执行之前产生N个SIGCHLD信号，此时sig_child调用次数不一定，**因为unix的信号是不排队的**



正确的解决办法是调用waitpid而不是wait，这个办法的方法为：信号处理函数中，在一个循环内调用waitpid，以获取所有已终止子进程的状态。我们必须指定WNOHANG选项，他告知waitpid在有尚未终止的子进程在运行时不要阻塞。

我们不能在循环内调用wait，因为没有办法防止wait在尚有未终止的子进程在运行时阻塞，wait将会阻塞到现有的子进程中第一个终止为止

```c
void sig_chld(int signo) {
    pid_t pid;
    int stat;
    while( (pid = waitpid(-1, &stat, WNOHANG)) > 0 ) {
        printf( "child %d exit\n", pid );
    }
    return;
}
```



什么样的程序需要避免僵尸进程，毕竟SIGCHLD信号并不总是需要处理



### 5. 如何处理zombie进程

父进程被终止，其子进程中的僵尸进程的父进程ID被重置为1(init进程)，由init进程wait它们，从而清除僵尸状态



一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。



##### 5.1 怎么找出僵尸进程

`ps / top` 等命令   `<defunct>`指明僵尸进程

如何查看linux系统上的僵尸进程，如何统计有多少僵尸进程？

```sh
ps -ef | grep defunct

# ps 查找状态为Z的进程，Z就是代表zombie process,僵尸进程的意思

# top命令查看时有一栏为S,如果状态为Z说明它就是僵尸进程。
Tasks:  95 total,   1 running,  94 sleeping,   0 stopped,   0 zombie
```



##### 5.2 怎么彻底杀死它们

一般僵尸进程很难直接kill掉，不过您可以kill僵尸爸爸。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失



### 6. 附录

wait & waitpid

系统中的僵尸进程都要由wait系统调用来回收

函数原型

```c++
#include<sys/types.h>
#include<sys/wait.h>
// 
// 执行成功则返回子进程识别码(PID) ,如果有错误发生则返回返回值-1。失败原因存于 errno 中
pid_t wait(int *status);
```

进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。



### ref

 http://www.cnblogs.com/yuxc/archive/2012/11/04/2753391.html

http://www.cnblogs.com/yuxingfirst/p/3165407.html